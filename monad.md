### 1. What is monad in Haskell?
Monad is a _typeclass_:
- Design goal of this typeclass: do not write code if the code can be automatically generated by rules of this typeclass
- How to achieve the goal: automatically deriving implicit standard implementation for common computation
- Basic rules for members in this typeclass: function `return` and `bind`

### 2. What is class in Haskell?
A _class_ or a _typeclass_ is a category of types those share a same set of rules/functions.

Similar thoughts in other languages:
- Java: interface
- C++: abstract class

Class examples:
- `Eq`
  - member rules (any type in `Eq` needs to implement): `==` and `/=`
  - member type instances: `Int`, `String`, and `Char`
- `Enum`
  - member rules (any type in `Enum` needs to implement): `succ` and `pred`
  - member type instances: `Bool`, `Char`, and `Float`
- `Monad`
  - member rules (any type in `Monad` needs to implement): `return`, `>>=` (bind), `>>`, and `fail`
  - member type instances: `[]` (list), `Maybe`, and `State`
  
### 3. What is the killer app of monad (to save code)?
- Short circuiting (`Maybe` monad, demonstrated in the next question)
- Keeping states with immutable variables in Haskell (`State` monad)
- Avoiding verbose syntax when implementing exception handling (`Except` monad)

### 4. What does it look like to save code using monad?
Check the following example and compare the first 2 non-monad implementations with the last 3 monad implementations.

**Example**: chain the 3 functions below and implement `func :: a -> Maybe d`:
``` Haskell
-- first do computationX, pass the result into computationY,
--   then pass the second result to computationZ, finally output
-- in any step, if an error occur and the step returns Nothing,
--   skip the following steps and return Nothing
computationX :: a -> Maybe b
computationY :: b -> Maybe c
computationZ :: c -> Maybe d
```

1. An implementation without knowing `Maybe` is a monad (the modular way):
``` Haskell
funcB :: Maybe b -> Maybe c
funcB Nothing = Nothing
funcB (Just x) = computationY x

funcC :: Maybe c -> Maybe d
funcC Nothing = Nothing
funcC (Just x) = computationZ x

func = funcC . funcB . computationX
```

2. Another implementation without knowing `Maybe` is a monad (the monolithic way):
``` Haskell
func x = w
  where
    my = computationX x
    y = case my of
        Nothing -> Nothing
        Just y -> computationY y
    w = case y of
        Nothing -> Nothing
        Just z -> computationZ z
```

3. An implementation knowing `Maybe` is a monad:
``` Haskell
func x = do
  y <- computationX x
  z <- computationY y
  computationZ z
```

4. Another monad version using the bind operator:
``` Haskell
func x = computationX x >>= computationY >>= computationZ
```

5. Another monad version with Kleisli composition:
``` Haskell
func = computationX >=> computationY >=> computationZ
```

#### What is the difference
The `Nothing` situation is automatically handled and is transparent to the developer, which leads to much cleaner syntax.
- `Maybe` defined only as `Nothing | Just a` does not do the magic
- putting `Maybe` into the monad typeclass does the magic
  - Haskell gives rules to `Maybe` on how to handle `Nothing` when chained togeter
  - the set of rules satisflies the monad typeclass, i.e., `Maybe` a monad
  - the set of rules is already implemented in core Haskell
  - when using `>>=` and `>=>`, Haskell automatically generates code to handle the `Nothing` situation

### 5. Where to find more about monad?
- https://www.youtube.com/watch?v=ZhuHCtR3xq8&index=2&list=FLjosXY3GhJ1cIHAnqZM-QBQ
- http://learnyouahaskell.com/a-fistful-of-monads#the-monad-type-class
